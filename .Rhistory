# Summary statistics
summary_stats <- data %>%
group_by(Treatment) %>%
summarise(across(c(Plug.Moisture, Sand.Moisture, Height, Leaf.Height, Height.Difference),
list(mean = mean, sd = sd, median = median, min = min, max = max), na.rm = TRUE))
print(summary_stats)
# Check for normality
shapiro_results <- list(
Plug.Moisture = shapiro.test(data$Plug.Moisture)$p.value,
Sand.Moisture = shapiro.test(data$Sand.Moisture)$p.value,
Height = shapiro.test(na.omit(data$Height))$p.value,
Leaf.Height = shapiro.test(data$Leaf.Height)$p.value,
Height.Difference = shapiro.test(data$Height.Difference)$p.value
)
print(shapiro_results)
# Determine test based on normality
anova_results <- list()
test_type <- list()
for (metric in names(shapiro_results)) {
if (shapiro_results[[metric]] > 0.05) {
model <- aov(as.formula(paste(metric, "~ Treatment")), data = data)
anova_results[[metric]] <- summary(model)[[1]][["Pr(>F)"]][1]
test_type[[metric]] <- "ANOVA"
} else {
model <- kruskal.test(as.formula(paste(metric, "~ Treatment")), data = data)
anova_results[[metric]] <- model$p.value
test_type[[metric]] <- "Kruskal-Wallis"
}
}
print(anova_results)
# Define a Named Vector for Y-axis Labels
y_labels <- c(
"Plug.Moisture" = "Plug moisture (%)",
"Sand.Moisture" = "Sand moisture (%)",
"Height" = "Plant height (cm)",
"Leaf.Height" = "Leaf height (cm)",
"Height.Difference" = "Height difference (cm)"
)
create_boxplot <- function(metric, p_value, test_used, y_label) {
plot <- ggplot(data, aes(x = Treatment, y = !!sym(metric), fill = Treatment)) +
geom_boxplot() +
scale_fill_manual(values = c("lightblue", "#FFA07A")) +
scale_x_discrete(labels = c("NP" = "Control", "P" = "Hydrogel")) +
theme_classic(base_size = 12) +
labs(x = NULL, y = y_labels[[metric]]) + # x-axis title is NULL for all plots initially
theme(
legend.position = "none",
panel.background = element_rect(fill = "transparent", color = NA),
plot.background = element_rect(fill = "transparent", color = NA),
axis.text.x = element_blank(), # Set x-axis tick labels to blank by default
axis.text.y = element_text(size = 12 * 2, color = "black"), # Black y-axis ticks
axis.title.x = element_blank(), # Set x-axis title to blank by default
axis.title.y = element_text(size = 12 * 2, color = "black") # Black y-axis label
) +
coord_cartesian(ylim = c(NA, max(data[[metric]], na.rm = TRUE) * 1.1)) +
annotate(
"text",
x = 1.5,
y = max(data[[metric]], na.rm = TRUE) * 1,
label = paste0(test_used, "\np = ", round(p_value, 3)),
size = 6
)
return(plot)
}
# Generate boxplots
boxplots <- lapply(names(anova_results), function(metric) {
create_boxplot(metric, anova_results[[metric]], test_type[[metric]], metric)
})
# --- MODIFICATION: Control x-axis labels for combined plot ---
n_plots <- length(boxplots)
n_cols <- 3 # Desired number of columns
n_rows <- ceiling(n_plots / n_cols)
# Identify plots that should keep their x-axis labels (bottom row of each column)
plots_to_keep_labels <- c()
for (col_idx in 1:n_cols) {
# Get all plot indices that fall into this column when arranged row-by-row
potential_column_indices <- seq(col_idx, n_plots, by = n_cols)
if (length(potential_column_indices) > 0) {
plots_to_keep_labels <- c(plots_to_keep_labels, tail(potential_column_indices, 1))
}
}
# Modify themes for plots not in the bottom row of their respective columns
for (i in seq_along(boxplots)) {
if (i %in% plots_to_keep_labels) {
boxplots[[i]] <- boxplots[[i]] +
theme(axis.text.x = element_text(size = 12 * 2, color = "black"), # Add x-axis tick labels back
axis.title.x = element_text(size = 12 * 2, color = "black")) # Add x-axis title back
}
}
# Print all plots (as before)
do.call(grid.arrange, c(boxplots, ncol=n_cols))
# Save all boxplots into one high-quality figure
combined_plot <- do.call(grid.arrange, c(boxplots, ncol=n_cols))
ggsave(
filename = "Figures/Greenhouse/combined_greenhouse_boxplots.png",
plot = combined_plot,
width = 15, # Adjust width as needed based on ncol and number of plots
height = 11, # Adjust height as needed
dpi = 600,
bg = "white" # Set background to white for the combined figure
)
print("\nAll greenhouse boxplots combined and saved to 'Figures/Greenhouse/combined_greenhouse_boxplots.png'")
################################################################################
################################################################################
#########################     Hydrogel Study      ##############################
##################     Greenhouse - Lovegrass - Weight Data ####################
#########################   University of Florida   ############################
#########################     Gage LaPierre      ###############################
#########################     2022 - 2025        ###############################
################################################################################
################################################################################
######################### Clears Environment & History   ########################
rm(list=ls(all=TRUE))
cat("\014")
#########################     Installs Packages    ##############################
list.of.packages <- c("tidyverse", "car", "gridExtra", "rstatix") # Added rstatix for easy post-hoc
new.packages <- list.of.packages[!(list.of.packages %in%
installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
# Load required libraries
library(tidyverse)
library(car)
library(gridExtra)
library(rstatix) # Load rstatix
# Load the dataset
data <- read.csv("Data/Polymer Study - Lovegrass Weight.csv")
# Convert categorical variables
data$Treatment <- as.factor(data$Treatment)
# Summary statistics
summary_stats <- data %>%
group_by(Treatment) %>%
summarise(across(c(Total.Weight, Root.Weight, Shoot.Weight, Lost.Weight,
Lost.Weight.., Root.., Shoot..),
list(mean = mean, sd = sd, median = median, min = min, max = max), na.rm = TRUE))
print(summary_stats)
# Check for normality
shapiro_results <- list(
Total.Weight = shapiro.test(data$Total.Weight)$p.value,
Root.Weight = shapiro.test(data$Root.Weight)$p.value,
Shoot.Weight = shapiro.test(na.omit(data$Shoot.Weight))$p.value,
Lost.Weight = shapiro.test(na.omit(data$Lost.Weight))$p.value,
Lost.Weight.. = shapiro.test(data$Lost.Weight..)$p.value,
Root.. = shapiro.test(data$Root..)$p.value,
Shoot.. = shapiro.test(data$Shoot..)$p.value
)
print(shapiro_results)
# Determine test based on normality and store results
anova_results <- list()
test_type <- list()
# Store models for post-hoc analysis
models <- list()
for (metric in names(shapiro_results)) {
if (shapiro_results[[metric]] > 0.05) {
model <- aov(as.formula(paste(metric, "~ Treatment")), data = data)
anova_results[[metric]] <- summary(model)[[1]][["Pr(>F)"]][1]
test_type[[metric]] <- "ANOVA"
models[[metric]] <- model # Store ANOVA model
} else {
model <- kruskal.test(as.formula(paste(metric, "~ Treatment")), data = data)
anova_results[[metric]] <- model$p.value
test_type[[metric]] <- "Kruskal-Wallis"
models[[metric]] <- model # Store Kruskal-Wallis result (not a model object for post-hoc in the same way)
}
}
print(anova_results)
# Define a mapping of metrics to desired y-axis labels.
y_labels <- c(
"Total.Weight" = "Total biomass (g)",
"Root.Weight" = "Root biomass (g)",
"Shoot.Weight" = "Shoot biomass (g)",
"Lost.Weight" = "Shoot biomass loss (g)",
"Lost.Weight.." = "Shoot biomass loss ratio (%)",
"Root.." = "Root mass ratio (%)",
"Shoot.." = "Shoot mass ratio (%)"
)
# Function to create boxplots and annotate significance and test type
create_boxplot <- function(metric, p_value, test_used, y_label) {
plot <- ggplot(data, aes(x = Treatment, y = !!sym(metric), fill = Treatment)) +
geom_boxplot() +
scale_fill_manual(values = c("lightblue", "#FFA07A")) +
scale_x_discrete(labels = c("NP" = "Control", "P" = "Hydrogel")) +
theme_classic(base_size = 12) +
labs(x = NULL, y = y_labels[[metric]]) + # x-axis title is NULL for all plots initially
theme(
legend.position = "none",
panel.background = element_rect(fill = "transparent", color = NA),
plot.background = element_rect(fill = "transparent", color = NA),
axis.text.x = element_text(size = 12 * 2, color = "black"), # Default x-axis ticks are visible
axis.text.y = element_text(size = 12 * 2, color = "black"),
axis.title.x = element_text(size = 12 * 2, color = "black"),
axis.title.y = element_text(size = 12 * 2, color = "black")
) +
coord_cartesian(ylim = c(NA, max(data[[metric]], na.rm = TRUE) * 1.1)) +
annotate(
"text",
x = 1.5,
y = max(data[[metric]], na.rm = TRUE) * 1,
label = paste0(test_used, "\np = ", round(p_value, 3)),
size = 6
)
return(plot)
}
# Generate boxplots
# Create a named list of plots for easier reordering
all_boxplots_named <- lapply(names(anova_results), function(metric) {
setNames(list(create_boxplot(metric, anova_results[[metric]], test_type[[metric]], metric)), metric)
}) %>%
unlist(recursive = FALSE) # Unlist to get a flat named list of plots
# Define the desired order of metrics
desired_order_metrics <- c(
"Shoot.Weight",
"Shoot..",
"Lost.Weight",
"Lost.Weight..",
"Root.Weight",
"Root..",
"Total.Weight"
)
# Reorder the boxplots list according to the desired order
boxplots_ordered <- all_boxplots_named[desired_order_metrics]
# --- MODIFICATION: Control x-axis labels for combined plot ---
n_plots <- length(boxplots_ordered) # Use the length of the ordered list
n_cols <- 3 # Desired number of columns
n_rows <- ceiling(n_plots / n_cols)
# Identify plots that should keep their x-axis labels (bottom row of each column)
plots_to_keep_labels <- c()
for (col_idx in 1:n_cols) {
# Get all plot indices that fall into this column when arranged row-by-row
potential_column_indices <- seq(col_idx, n_plots, by = n_cols)
if (length(potential_column_indices) > 0) {
plots_to_keep_labels <- c(plots_to_keep_labels, tail(potential_column_indices, 1))
}
}
# Modify themes for plots not in the bottom row of their respective columns
for (i in seq_along(boxplots_ordered)) { # Iterate through the ordered list
if (!(i %in% plots_to_keep_labels)) {
boxplots_ordered[[i]] <- boxplots_ordered[[i]] +
theme(axis.text.x = element_blank(), # Remove x-axis tick labels
axis.title.x = element_blank()) # Ensure x-axis title is also blank
}
}
# Print all plots (as before, for individual display if desired)
do.call(grid.arrange, c(boxplots_ordered))
# Save all boxplots into one high-quality figure
combined_plot <- do.call(grid.arrange, c(boxplots_ordered, ncol=n_cols)) # Use the ordered list
# Save the combined plot as a high-quality PNG
ggsave(
filename = "Figures/Greenhouse/combined_greenhouse_biomass_boxplots.png",
plot = combined_plot,
width = 10, # Adjusted width for 2 columns
height = 14, # Adjusted height for 4 rows
dpi = 300,
bg = "white" # Set background to white for the combined figure
)
print("\nAll greenhouse biomass boxplots combined and saved to 'Figures/Greenhouse/combined_greenhouse_biomass_boxplots.png'")
# --- NEW: Summary of all ANOVA/Kruskal Tests ---
print("\n--- Summary of Greenhouse Statistical Test Results (ANOVA/Kruskal-Wallis) ---")
summary_table_greenhouse <- tibble(
Metric = names(anova_results),
Test_Used = unlist(test_type),
P_Value = unlist(anova_results)
) %>%
mutate(
P_Value = round(P_Value, 3), # Round p-values for display
Significance = ifelse(P_Value < 0.05, "*", "") # Add a significance indicator
)
print(summary_table_greenhouse)
write.csv(summary_table_greenhouse, "greenhouse_statistical_summary.csv", row.names = FALSE)
print("Summary table saved to 'greenhouse_statistical_summary.csv'")
# --- NEW: Post-hoc Tests ---
print("\n--- Greenhouse Post-hoc Test Results ---")
post_hoc_results <- list()
for (metric in names(anova_results)) {
# Post-hoc tests are typically only meaningful for tests with p < 0.05
if (anova_results[[metric]] < 0.05) {
if (test_type[[metric]] == "ANOVA") {
# For ANOVA, perform pairwise t-test
pairwise_test <- data %>%
pairwise_t_test(as.formula(paste(metric, "~ Treatment")), p.adjust.method = "bonferroni")
post_hoc_results[[metric]] <- pairwise_test
print(paste0("Post-hoc for ", metric, " (ANOVA - Difference in Means):"))
# Explicitly select and print key columns for clarity
print(pairwise_test %>% select(group1, group2, estimate, p.adj))
} else if (test_type[[metric]] == "Kruskal-Wallis") {
# For Kruskal-Wallis, use wilcox.test from base R to get Hodges-Lehmann estimate and CI
# and pairwise_wilcox_test from rstatix for adjusted p-value.
# Perform Wilcoxon rank sum test to get Hodges-Lehmann estimate and CI
# Ensure data is filtered for the current metric and groups
group_data <- data %>% select(Treatment, !!sym(metric)) %>% drop_na()
# Assuming 'NP' is control and 'P' is hydrogel applied
# Adjust order if 'P' should be subtracted from 'NP'
wilcox_base_test <- wilcox.test(
x = group_data %>% filter(Treatment == "NP") %>% pull(!!sym(metric)),
y = group_data %>% filter(Treatment == "P") %>% pull(!!sym(metric)),
conf.int = TRUE,
conf.level = 0.95 # You can adjust confidence level if needed
)
# Get adjusted p-value from rstatix's pairwise_wilcox_test
pairwise_rstatix_test <- data %>%
pairwise_wilcox_test(as.formula(paste(metric, "~ Treatment")), p.adjust.method = "bonferroni")
# Extract relevant info and rename for consistency
# Find the row corresponding to the "NP" vs "P" comparison
p_adj_value <- pairwise_rstatix_test %>%
filter(group1 == "NP" & group2 == "P") %>%
pull(p.adj)
formatted_result <- tibble(
group1 = "NP",
group2 = "P",
estimate = wilcox_base_test$estimate, # Hodges-Lehmann estimate
conf.low = wilcox_base_test$conf.int[1],
conf.high = wilcox_base_test$conf.int[2],
p.adj = p_adj_value
)
post_hoc_results[[metric]] <- formatted_result # Store the modified tibble
print(paste0("Post-hoc for ", metric, " (Kruskal-Wallis - Hodges-Lehmann Estimate and CI):"))
# Explicitly select and print key columns for clarity, now including 'estimate' and CI
print(formatted_result %>% select(group1, group2, estimate, conf.low, conf.high, p.adj))
}
} else {
print(paste0("No significant differences for ", metric, " (p = ", round(anova_results[[metric]], 3), "). No post-hoc test performed."))
}
}
# Save post-hoc results if any
if (length(post_hoc_results) > 0) {
# Combine all post-hoc results into a single data frame for saving
all_post_hoc_df <- bind_rows(post_hoc_results, .id = "Metric")
write.csv(all_post_hoc_df, "greenhouse_post_hoc_summary.csv", row.names = FALSE)
print("\nPost-hoc results saved to 'greenhouse_post_hoc_summary.csv'")
} else {
print("\nNo significant results from ANOVA/Kruskal-Wallis, so no post-hoc tests were performed or saved.")
}
# Save the combined plot as a high-quality PNG
ggsave(combined_plot,
filename = "Figures/Greenhouse/combined_greenhouse_biomass_boxplots.png",
plot = combined_plot,
width = 10, # Adjusted width for 2 columns
height = 14, # Adjusted height for 4 rows
dpi = 300,
bg = "white" # Set background to white for the combined figure
)
################################################################################
################################################################################
#########################     Hydrogel Study      ##############################
##################     Greenhouse - Lovegrass - Weight Data ####################
#########################   University of Florida   ############################
#########################     Gage LaPierre      ###############################
#########################     2022 - 2025        ###############################
################################################################################
################################################################################
######################### Clears Environment & History   ########################
rm(list=ls(all=TRUE))
cat("\014")
#########################     Installs Packages    ##############################
list.of.packages <- c("tidyverse", "car", "gridExtra", "rstatix") # Added rstatix for easy post-hoc
new.packages <- list.of.packages[!(list.of.packages %in%
installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
# Load required libraries
library(tidyverse)
library(car)
library(gridExtra)
library(rstatix) # Load rstatix
# Load the dataset
data <- read.csv("Data/Polymer Study - Lovegrass Weight.csv")
# Convert categorical variables
data$Treatment <- as.factor(data$Treatment)
# Summary statistics
summary_stats <- data %>%
group_by(Treatment) %>%
summarise(across(c(Total.Weight, Root.Weight, Shoot.Weight, Lost.Weight,
Lost.Weight.., Root.., Shoot..),
list(mean = mean, sd = sd, median = median, min = min, max = max), na.rm = TRUE))
print(summary_stats)
# Check for normality
shapiro_results <- list(
Total.Weight = shapiro.test(data$Total.Weight)$p.value,
Root.Weight = shapiro.test(data$Root.Weight)$p.value,
Shoot.Weight = shapiro.test(na.omit(data$Shoot.Weight))$p.value,
Lost.Weight = shapiro.test(na.omit(data$Lost.Weight))$p.value,
Lost.Weight.. = shapiro.test(data$Lost.Weight..)$p.value,
Root.. = shapiro.test(data$Root..)$p.value,
Shoot.. = shapiro.test(data$Shoot..)$p.value
)
print(shapiro_results)
# Determine test based on normality and store results
anova_results <- list()
test_type <- list()
# Store models for post-hoc analysis
models <- list()
for (metric in names(shapiro_results)) {
if (shapiro_results[[metric]] > 0.05) {
model <- aov(as.formula(paste(metric, "~ Treatment")), data = data)
anova_results[[metric]] <- summary(model)[[1]][["Pr(>F)"]][1]
test_type[[metric]] <- "ANOVA"
models[[metric]] <- model # Store ANOVA model
} else {
model <- kruskal.test(as.formula(paste(metric, "~ Treatment")), data = data)
anova_results[[metric]] <- model$p.value
test_type[[metric]] <- "Kruskal-Wallis"
models[[metric]] <- model # Store Kruskal-Wallis result (not a model object for post-hoc in the same way)
}
}
print(anova_results)
# Define a mapping of metrics to desired y-axis labels.
y_labels <- c(
"Total.Weight" = "Total biomass (g)",
"Root.Weight" = "Root biomass (g)",
"Shoot.Weight" = "Shoot biomass (g)",
"Lost.Weight" = "Shoot biomass loss (g)",
"Lost.Weight.." = "Shoot biomass loss ratio (%)",
"Root.." = "Root mass ratio (%)",
"Shoot.." = "Shoot mass ratio (%)"
)
# Function to create boxplots and annotate significance and test type
create_boxplot <- function(metric, p_value, test_used, y_label) {
plot <- ggplot(data, aes(x = Treatment, y = !!sym(metric), fill = Treatment)) +
geom_boxplot() +
scale_fill_manual(values = c("lightblue", "#FFA07A")) +
scale_x_discrete(labels = c("NP" = "Control", "P" = "Hydrogel")) +
theme_classic(base_size = 12) +
labs(x = NULL, y = y_labels[[metric]]) + # x-axis title is NULL for all plots initially
theme(
legend.position = "none",
panel.background = element_rect(fill = "transparent", color = NA),
plot.background = element_rect(fill = "transparent", color = NA),
axis.text.x = element_text(size = 12 * 2, color = "black"), # Default x-axis ticks are visible
axis.text.y = element_text(size = 12 * 2, color = "black"),
axis.title.x = element_text(size = 12 * 2, color = "black"),
axis.title.y = element_text(size = 12 * 2, color = "black")
) +
coord_cartesian(ylim = c(NA, max(data[[metric]], na.rm = TRUE) * 1.1)) +
annotate(
"text",
x = 1.5,
y = max(data[[metric]], na.rm = TRUE) * 1,
label = paste0(test_used, "\np = ", round(p_value, 3)),
size = 6
)
return(plot)
}
# Generate boxplots
# Create a named list of plots for easier reordering
all_boxplots_named <- lapply(names(anova_results), function(metric) {
setNames(list(create_boxplot(metric, anova_results[[metric]], test_type[[metric]], metric)), metric)
}) %>%
unlist(recursive = FALSE) # Unlist to get a flat named list of plots
# Define the desired order of metrics
desired_order_metrics <- c(
"Shoot.Weight",
"Shoot..",
"Lost.Weight",
"Lost.Weight..",
"Root.Weight",
"Root..",
"Total.Weight"
)
# Reorder the boxplots list according to the desired order
boxplots_ordered <- all_boxplots_named[desired_order_metrics]
# --- MODIFICATION: Control x-axis labels for combined plot ---
n_plots <- length(boxplots_ordered) # Use the length of the ordered list
n_cols <- 3 # Desired number of columns
n_rows <- ceiling(n_plots / n_cols)
# Identify plots that should keep their x-axis labels (bottom row of each column)
plots_to_keep_labels <- c()
for (col_idx in 1:n_cols) {
# Get all plot indices that fall into this column when arranged row-by-row
potential_column_indices <- seq(col_idx, n_plots, by = n_cols)
if (length(potential_column_indices) > 0) {
plots_to_keep_labels <- c(plots_to_keep_labels, tail(potential_column_indices, 1))
}
}
# Modify themes for plots not in the bottom row of their respective columns
for (i in seq_along(boxplots_ordered)) { # Iterate through the ordered list
if (!(i %in% plots_to_keep_labels)) {
boxplots_ordered[[i]] <- boxplots_ordered[[i]] +
theme(axis.text.x = element_blank(), # Remove x-axis tick labels
axis.title.x = element_blank()) # Ensure x-axis title is also blank
}
}
# Print all plots (as before, for individual display if desired)
do.call(grid.arrange, c(boxplots_ordered))
# Save all boxplots into one high-quality figure
combined_plot <- do.call(grid.arrange, c(boxplots_ordered, ncol=n_cols)) # Use the ordered list
# Save the combined plot as a high-quality PNG
ggsave(combined_plot,
filename = "Figures/Greenhouse/combined_greenhouse_biomass_boxplots.png",
plot = combined_plot,
width = 10, # Adjusted width for 2 columns
height = 14, # Adjusted height for 4 rows
dpi = 300,
bg = "white" # Set background to white for the combined figure
)
# Save all boxplots into one high-quality figure
combined_plot <- do.call(grid.arrange, c(boxplots_ordered, ncol=n_cols)) # Use the ordered list
# Save the combined plot as a high-quality PNG
ggsave(combined_plot,
filename = "Figures/Greenhouse/combined_greenhouse_biomass_boxplots.png",
width = 10, # Adjusted width for 2 columns
height = 14, # Adjusted height for 4 rows
dpi = 300,
bg = "white" # Set background to white for the combined figure
)
# Save all boxplots into one high-quality figure
combined_plot <- do.call(grid.arrange, c(boxplots_ordered, ncol=n_cols)) # Use the ordered list
# Save the combined plot as a high-quality PNG
ggsave(combined_plot,
filename = "Figures/Greenhouse/combined_greenhouse_biomass_boxplots.png",
width = 10, # Adjusted width for 2 columns
height = 14, # Adjusted height for 4 rows
dpi = 300,
bg = "white" # Set background to white for the combined figure
)
